# Android

## 안드로이드 기본 설정

### 안드로이드 스튜디오 설치

[Android 개발자  |  Android Developers](https://developer.android.com/?hl=ko)

### 공식홈페이지에서 스튜디오 다운로드 페이지 이동

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2013.png)

### 공식 홈페이지에서 제공하는 exe파일 다운로드

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2014.png)

### exe파일 실행

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2015.png)

### 순서대로 체크해서 실행

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2016.png)

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2017.png)

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2018.png)

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2019.png)

### 모든 항목을 완료

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2020.png)

---

### 안드로이드 기본 프로젝트 설치

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2021.png)

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2022.png)

### Empty Activity

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2023.png)

### Empty Views Activity

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2024.png)

### 정상적으로 작동하는 확인!!

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2025.png)

---

## JetPack Compose 설정

### **JetPack Compose란**❓

Jetpack Compose는 네이티브 UI를 빌드하기 위한 **Android의 최신 권장 도구 키트**
Jetpack Compose는 Android에서의 **UI 개발을 간소화**하고 가속화합니다. 간단한 코드, 강력한 도구, 직관적인 Kotlin API를 사용하여 앱을 빠르고 생동감 있게 구현 가능합니다.

**jetPack을 이용하면 생기는 장점** 

- 코드의 감소
- 직관적
- 빠른 개발 과정
- 강력한 성능 지원

### build.gradle 설정

```groovy
// build.gradle
android {
    buildFeatures {
        compose true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.4.2"
    }
}
```

compose컴파일은 kotlin 컴파일과 버젼별로 호환되는 것이 다르기 때문에 맞춰줘야합니다.
해당 버젼별 호환성 지도를 참고하여 설정해주세요.

[Compose와 Kotlin의 호환성 지도  |  Android 개발자  |  Android Developers](https://developer.android.com/jetpack/androidx/releases/compose-kotlin?hl=ko)

### 필요한 라이브러리 설정

```groovy
implementation 'androidx.compose:compose-bom:2023.01.00'
androidTestImplementation 'androidx.compose:compose-bom:2023.01.00'

// Choose one of the following:
// Material Design 3
implementation 'androidx.compose.material3:material3'
// or Material Design 2
implementation 'androidx.compose.material:material'
// or skip Material Design and build directly on top of foundational components
implementation 'androidx.compose.foundation:foundation'
// or only import the main APIs for the underlying toolkit systems,
// such as input and measurement/layout
implementation 'androidx.compose.ui:ui'
```

compose는 Material디자인을 사용합니다. 해당 디자인을 학습하고 싶으시면 아래 링크를 참조해서 학습하는 것을 추천드립니다.

[Material Design](https://m3.material.io/)

### 선택적 라이브러리 설정

```groovy
// 선택 사항 - Material이 자동으로 포함되므로
// 아이콘만 필요하지만 Material3 또는 Foundation을 기반으로 한 
// 사용자 정의 디자인 시스템을 사용하는 경우에만 추가하십시오.
implementation 'androidx.compose.material:material-icons-core'
// 선택 사항 - 전체 Material 아이콘 세트 추가
implementation 'androidx.compose.material:material-icons-extended'
// 선택 사항 - 창 크기 유틸리티 추가
implementation 'androidx.compose.material3:material3-window-size-class'
// 선택 사항 - 활동 통합
implementation 'androidx.activity:activity-compose:{version}'
// 선택 사항 - 뷰모델 통합
implementation 'androidx.lifecycle:lifecycle-viewmodel-compose:{version}'
implementation 'androidx.lifecycle:lifecycle-runtime-ktx:{version}'
// 선택 사항 - LiveData 통합
implementation 'androidx.compose.runtime:runtime-livedata'
// 선택 사항 - RxJava 통합
implementation 'androidx.compose.runtime:runtime-rxjava2'
```

### 코드로 구현한 UI확인 라이브러리

```groovy
 // UI Tests
 androidTestImplementation 'androidx.compose.ui:ui-test-junit4'
 debugImplementation 'androidx.compose.ui:ui-test-manifest'
```

## Retrofit 설정 및 사용 가이드

### Retrofit 설정 구성요소

- `data class` or `DTO` ( 데이터를 건네거나 받아올 때 사용하는 객체 )
- interface ( retrofit 객체가 API요청을 보낼 메소드 )
    - GET, POST, PUT, DELETE 등등
- Retrofit 객체를 생성할 클래스

```kotlin
⚠️ 주의사항
애뮬레이터를 사용해서 로컬 통신테스트를 할 경우
로컬IP 주소를 이용해서 URL을 설정해주셔야합니다.!!

CMD -> ipconfig -> IPv4주소

✅ URL => http://{IP주소}:port/
❌ URL => http://localhost:port/
```

---

### Gson 라이브러리 사용

Http통신을 할 때 JSON형식으로 변환 또는 JSON객체를 java객체로 변환하는데 사용하기 위해서 `Gson` 라이브러리를 사용하였습니다.

Gson은 java의 기본적인 데이터 객체뿐만 아니라 사용자가 정의한 데이터 클래스로도 간편하게 변환이 가능

### GSON 의존성 추가

```kotlin
implementation 'com.google.code.gson:gson:2.8.6'
```

### Retrofit 관련 의존성 추가

```kotlin
// Gson
implementation 'com.google.code.gson:gson:${gson_version}'
// Retrofit
implementation 'com.squareup.retrofit2:retrofit:${retrofit_version}'
implementation 'com.squareup.retrofit2:converter-gson:${version}'
// OkHttp
implementation 'com.squareup.okhttp3:okhttp:${version}'
implementation 'com.squareup.okhttp3:logging-interceptor:${version}'
```

의존성을 추가해주세요.!!

### 권한 설정 ( AndroidMainfest에 인터넷 관련 권한 )

```kotlin
<uses-permission android:name="android.permission.INTERNET"/>
```

HTTP 통신을 하려면 기본적으로 인터넷을 이용해야 하므로 AndroidMainfest에 인터넷 관련 권한을 추가

### 결과값 맵핑

받아온 데이터를 객체와 맵핑하기 위해서 @SerializedName 어노테이션을 사용

```kotlin
data class SignUpResponseBody(
    @SerializedName("result")
    val result: String?,
    @SerializedName("status")
    val status: String?
)
```

### API 인터페이스 설정

```kotlin
interface ExampleService {

    @Headers("Content-Type: application/json")
    @POST("URI")
    fun addUserByEnqueue(
				@Body userInfo: SignUpRequestBody
		): Call<SignUpResponseBody> // Call 은 흐름처리 기능을 제공해줌

}
```

@Header 어노테이션을 사용하면 Request Header에 담아줄 데이터를 넣어줄 수 있습니다.

@POST , @GET, @PUT, @DELETE : RestAPI를 설정해주시면 됩니다.

- 만약 POST방식으로 Body에 데이터를 삽입하려면 
변수 앞에 @Body 어노테이션을 붙여주세요.
- 객체가 아닌 단일로 설정해주려면 @Field 어노테이션을 사용해주세요.
    
    ex) @Field(”멤버명”) username : String?
    

Call은 흐름 처리 기능을 제공하는 retrofit2 패키지 안에 있는 interface ( Call<T> )

### Retrofit 객체를 구현

```kotlin
Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
```

안드로이드에서는 로그캣 창에서 모니터링이 가능합니다. 
패킷 내용을 모니터링 하고 싶다면 아래 코드를 추가 및 수정해주세요.

```kotlin
OkHttpClient.Builder()
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BODY
            })
            .build()
```

```kotlin
private val retrofit : Retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .client(okHttpClient)
        .build()
```

RestAPI 설정을 해준 인터페이스를 추가해주시면 Retrofit 객체를 사용할 준비는 끝이 납니다.

```kotlin
val memberApi = retrofit.create(MemberRepository::class.java)
```

🚨 Retrofit의 객체는 비용이 높기 때문에 여러 객체를 사용하게 되면 자원낭비 및 통신에 혼선이 발생할 수 있습니다. 여기서 object키워드를 사용해서 싱글톤으로 만들어 줄 수 있습니다.

```kotlin
object AlarmonyServer {
		.. 생략 ..
}
```

---

### 서버와 API통신을 하는 클래스를 구현

Call 작업은 두 가지로 실행된다.

- **execute**를 사용하면 request를 보내고 response를 받는 행위를 동기적으로 수행한다. (동기 방식)
- **enqueue** 작업을 실행하면 request는 비동기적으로 보내고, response는 콜백으로 받게 된다. (비동기 방식)

동기 방식의 execute를 사용해본 적은 없지만 찾아보니 UnitTest 등을 수행할 때 쓰이는 경우가 있다고 한다.

```kotlin
class RetrofitWork(private val userInfo: SignUpRequestBody) {
    fun work() {
        val service = RetrofitAPI.emgMedService

//        Call 작업은 두 가지로 실행됨
//        execute 를 사용하면 request 를 보내고 response 를 받는 행위를 동기적으로 수행한다.
//        enqueue 작업을 실행하면 request 는 비동기적으로 보내고, response 는 콜백으로 받게 된다.
        service.addUserByEnqueue(userInfo)
            .enqueue(object : retrofit2.Callback<SignUpResponseBody> {
                override fun onResponse(
                    call: Call<SignUpResponseBody>,
                    response: Response<SignUpResponseBody>
                ) {
                    if (response.isSuccessful) {
                        val result = response.body()
                        Log.d("회원가입 성공", "$result")
                    }
                }

                override fun onFailure(call: Call<SignUpResponseBody>, t: Throwable) {
                    Log.d("회원가입 실패", t.message.toString())
                }
            })
    }
}
```

Callback 인터페이스는 필수적으로 2가지 메서드를 오버 라이딩해야 하는데 이는 2가지로 나뉜다.

- 통신에 성공했을 경우는 **onResponse**
- 통신에 실패했을 경우는 **onFailure**

실패한 경우는 그에 따른 예외처리를 수행

## Retrofit 과 Coroutine 사용

### 공식문서 참조!!

[Kotlin 코루틴으로 앱 성능 향상  |  Android 개발자  |  Android Developers](https://developer.android.com/kotlin/coroutines-adv?hl=ko)

### **코루틴 정의**

### 코루틴 설정

```groovy
// Kotlin components
implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.1"
implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.1"

// 코틀린을 쓰는 경우
implementation 'androidx.work:work-runtime-ktx:2.7.1'
```

## Room Database 설정

- Room은 스마트폰 내장 DB에 **데이터를 저장하기 위해 사용하는 라이브러리**
- 앱에서 Room을 사용하기 위해 build.gradle에 종속 항목 추가
    - annotationProcessor는 코틀린에서 kapt 컴파일러 플러그인과 함께 사용하도록 되어있으므로 gradle의 맨 앞 부분에 플러그인 추가

```kotlin
plugins {
    id 'kotlin-kapt'
}

dependencies {
  def room_version = "2.2.6"

  implementation "androidx.room:room-runtime:$room_version"
  kapt "androidx.room:room-compiler:$room_version"

  implementation "androidx.room:room-ktx:$room_version"
}
```

Room에는 3가지 주요 구성 요소

- Database Class : 데이터베이스를 보유함
- Data Entites : 앱의 데이터베이스에 있는 테이블을 나타냄
- DAO(Data Access Object) : 앱이 데이터베이스의 데이터를 쿼리, 업데이트, 삽입 및 삭제하는 데 사용할 수 있는 메서드를 제공

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2026.png)

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2027.png)

# 1. Alarm (엔터티 클래스)

- @Entity 어노테이션 작성

```kotlin
@TypeConverters(DayConverters::class)
@Entity(tableName = "alarms")
class Alarm(
    @PrimaryKey
    val alarmId: Long,
    val title: String,
    val hour: Int,
    val minute: Int,
    val alarmDate: List<Boolean>,
    val soundName: String,
    val soundVolume: Int,
    val vibrate: Boolean,
    val host: Boolean,
    val content: String
) {
    companion object {
        fun toEntity(alarmDto: AlarmDto): Alarm {
            val alarm = Alarm(
                alarmDto.alarmId,
                alarmDto.title,
                alarmDto.hour,
                alarmDto.minute,
                alarmDto.alarmDate,
                alarmDto.soundName,
                alarmDto.soundVolume,
                alarmDto.vibrate,
                alarmDto.host,
                alarmDto.content
            )
            return alarm
        }
    }
}
```

# 2. AlarmDatabaseDao (데이터 액세스 개체)

- 인터페이스로 작성
- @Dao 어노테이션 작성
- Query 어노테이션은 사용자 지정 쿼리를 작성하는 데 사용
- 함수를 suspend로 표시하여 코루틴 내에서 호출 가능

```kotlin
@Dao
interface AlarmDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE) // 만약 동일한 PrimaryKey 가 있을 경우 덮어쓰기
    suspend fun insertAlarm(alarm: Alarm)

    @Query("SELECT * FROM alarms ORDER BY hour ASC, minute ASC")
    fun getAllAlarms(): LiveData<List<Alarm>>

    @Query("SELECT * FROM alarms")
    fun getAllAlarms2() : List<Alarm>

    @Query("SELECT * FROM alarms WHERE alarmId=:alarmId")
    fun getAlarmById(alarmId: Long): Alarm?

    @Update
    suspend fun updateAlarm(alarm: Alarm)

    @Delete
    suspend fun deleteAlarm(alarm: Alarm)

    @Query("DELETE FROM alarms")
    suspend fun deleteAllAlarms()
}
```

# 3 .AlarmDatabase(데이터베이스 클래스)

- RoomDatabase를 확장하는 추상 클래스 작성
- @Database 어노테이션 작성
    - 동기화된 메서드를 입력하는 스레드는 잠금을 가져오며, 잠금이 해제될 때까지 다른 스레드는 메서드에 들어갈 수 없음
    - @**Synchronized 어노테이션과 동일한 기능 제공**

```kotlin
@Database(entities = [Alarm::class], version = 1, exportSchema = false)
abstract class AlarmDatabase : RoomDatabase() {
    abstract fun alarmDao(): AlarmDao

    companion object {
        @Volatile
        private var INSTANCE: AlarmDatabase? = null

        fun getInstance(context: Context): AlarmDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AlarmDatabase::class.java,
                    "alarm_database"
                )
                    .fallbackToDestructiveMigration()
                    .build()
                INSTANCE = instance

                return INSTANCE!!
            }
        }
    }
}
```

# 4. TodoRepository (저장소 클래스)

- AlarmDatabaseDao를 생성자 매개 변수로 사용하는 리포지토리 클래스 작성
- 데이터베이스에 대한 모든 상호 작용은 이 저장소 계층을 통해 수행

```kotlin
class AlarmRepository(private val alarmDao: AlarmDao) {
    val readAllData : LiveData<List<Alarm>> = alarmDao.getAllAlarms()

    fun findAlarm(alarmId : Long) : Alarm? {
        val alarm : Alarm? = alarmDao.getAlarmById(alarmId)
        return alarm
    }

    fun getAllAlarms() : List<Alarm>? {
        val alarms = alarmDao.getAllAlarms2()
        return alarms
    }

    suspend fun addAlarm(alarm: Alarm) {
        alarmDao.insertAlarm(alarm)
    }

    suspend fun updateAlarm(alarm: Alarm) {
        alarmDao.updateAlarm(alarm)
    }

    suspend fun deleteAlarm(alarm: Alarm) {
        alarmDao.deleteAlarm(alarm)
    }

    suspend fun deleteAllAlarms() {
        alarmDao.deleteAllAlarms()
    }
}
```

# Android 및 서버 FCM 설정

## 순서

1. Firebase 설정
2. 안드로이드 세팅
3. 자바 세팅

### Firebase 설정

### 프로젝트 생성

1. 아래 사이트에서 Firebase 프로젝트를 생성한다.
    
    [](https://console.firebase.google.com/)
    
2. 프로젝트 생성
    
    ![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2028.png)
    
    ![안드로이드를 선택한다](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2029.png)
    
    안드로이드를 선택한다
    
    ![패키지 이름과, 앱 닉네임을 설정한다.](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2030.png)
    
    패키지 이름과, 앱 닉네임을 설정한다.
    

### 안드로이드 프로젝트에 넣을 세팅 파일

![google-service.json 파일을 다운받고, 안드로이드에 넣어주어야 한다.](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2031.png)

google-service.json 파일을 다운받고, 안드로이드에 넣어주어야 한다.

![해당 위치에 넣고, 다시 빌드해야 한다.](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2032.png)

해당 위치에 넣고, 다시 빌드해야 한다.

### 웹 서버에 넣을 세팅 파일

![json 파일을 받고, 웹 서버에 저장한다.](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2033.png)

json 파일을 받고, 웹 서버에 저장한다.

![저장 경로와 파일이름은 상관이 없으나, 나중에 쉽게 찾아서 쓸 경로로 두는 편이 좋다.](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2034.png)

저장 경로와 파일이름은 상관이 없으나, 나중에 쉽게 찾아서 쓸 경로로 두는 편이 좋다.

## 안드로이드 세팅

### build.gradle (Project)

```
dependencies{
	classpath 'com.google.gms:google-services:4.3.15'
}
```

### build.gradle (Module)

```
dependencies{
	implementation 'com.google.firebase:firebase-messaging:21.1.0'
}
...
apply plugin: 'com.google.gms.google-services'
```

### AndroidManifest.xml

```xml
...
// Internet permission 추가
<uses-permission android:name="android.permission.INTERNET"/>

// service추가 및 intent필터 추가
<application>
	<!--   서비스를 추가하고 인텐트 필터를 설정한다.   -->
  <service android:name=".MyFirebaseMessagingService"
      android:exported="true">
      <intent-filter>
          <action android:name="com.google.firebase.MESSAGING_EVENT"/>
      </intent-filter>
  </service>
...
</application>
```

### MyFirebaseMessagingService

```java
@Override
public void onNewToken(@NonNull String token) {
    super.onNewToken(token);
    //token을 서버로 전송
}

@Override
  public void onMessageReceived(@NonNull RemoteMessage remoteMessage) {
      super.onMessageReceived(remoteMessage);
      //수신한 메시지를 처리
			//알림 처리 예시는 아래 토글 참조
}
```

- 실제 소스코드
    
    ```java
    package com.fcmtests.alarmony;
    
    import android.annotation.SuppressLint;
    import android.app.Notification;
    import android.app.NotificationChannel;
    import android.app.NotificationManager;
    import android.app.Service;
    import android.os.Build;
    import android.util.Log;
    
    import androidx.annotation.NonNull;
    import androidx.core.app.NotificationCompat;
    import androidx.core.app.NotificationManagerCompat;
    
    import com.google.firebase.messaging.FirebaseMessagingService;
    import com.google.firebase.messaging.RemoteMessage;
    
    public class MyFirebaseMessagingService extends FirebaseMessagingService {
        private static final String CHANNEL_ID = "12345";
        private static final CharSequence CHANNEL_NAME = "FCMTest12345";
    
        //    @Override
    //    public void onNewToken(String token){
    //        Log.d("FCM Log", "Registration token: "+token);
    //    }
        @Override
        public void onNewToken(@NonNull String token) {
            super.onNewToken(token);
            //token을 서버로 전송
        }
    
        @SuppressLint("MissingPermission")
        @Override
        public void onMessageReceived(@NonNull RemoteMessage remoteMessage) {
            super.onMessageReceived(remoteMessage);
            //수신한 메시지를 처리
            NotificationManagerCompat notificationManager = NotificationManagerCompat.from(getApplicationContext());
    
            NotificationCompat.Builder builder = null;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                if (notificationManager.getNotificationChannel(CHANNEL_ID) == null) {
                    NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT);
                    notificationManager.createNotificationChannel(channel);
                }
                builder = new NotificationCompat.Builder(getApplicationContext(), CHANNEL_ID);
            }else {
                builder = new NotificationCompat.Builder(getApplicationContext());
            }
    
            String title = remoteMessage.getNotification().getTitle();
            String body = remoteMessage.getNotification().getBody();
    
            builder.setContentTitle(title)
                    .setContentText(body)
                    .setSmallIcon(R.drawable.ic_launcher_background);
    
            Notification notification = builder.build();
            notificationManager.notify(1, notification);
        }
    }
    ```
    

## Java 세팅

### Build.gradle

```java
dependencies{
	...
	implementation group: 'com.squareup.okhttp3', name: 'okhttp', version: '4.2.2'
	implementation 'com.google.firebase:firebase-admin:9.1.1'
	...
}
```

### FCMService.java

- 코드는 예시이다. 버전과 상황에 맞게 수정해야 한다.

### getAccessToken

```java
public String getAccessToken() throws IOException {
        // firebase로 부터 access token을 가져온다.

        GoogleCredentials googleCredentials = GoogleCredentials
                .fromStream(new ClassPathResource("fcm-config.json").getInputStream())
                .createScoped(Arrays.asList("https://www.googleapis.com/auth/cloud-platform"));

        googleCredentials.refreshIfExpired();

        return googleCredentials.getAccessToken().getTokenValue();

    }
```

### SendMessageTo

```java
public void sendMessageTo(String targetToken, String title, String body) throws IOException {
        String message = makeMessage(targetToken, title, body);
        log.info("Bearer " + targetToken);
        OkHttpClient client = new OkHttpClient();
        RequestBody requestBody = RequestBody.create(message,
                MediaType.get("application/json; charset=utf-8"));
        Request request = new Request.Builder()
                .url(urlInfo.getFcmApi())
                .post(requestBody)
                .addHeader(HttpHeaders.AUTHORIZATION, "Bearer " + getAccessToken())
                .addHeader(HttpHeaders.CONTENT_TYPE, "application/json; UTF-8")
                .build();

        log.info("Bearer " + getAccessToken());
        Response response = client.newCall(request).execute();

        System.out.println(response.body().string());
    }
```

### makeMessage

```java
public String makeMessage(String targetToken, String title, String body) throws JsonParseException, JsonProcessingException {
        FcmMessage fcmMessage = FcmMessage.builder()
                .message(FcmMessage.Message.builder()
                        .token(targetToken)
                        .notification(FcmMessage.Notification.builder()
                                .title(title)
                                .body(body)
                                .image(null)
                                .build()
                        ).build()).validateOnly(false).build();

        return objectMapper.writeValueAsString(fcmMessage);
    }
```

### FcmMessage

```java
package com.slembers.alarmony.alarm.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

@Builder
@AllArgsConstructor
@Getter
public class FcmMessage {
    private boolean validateOnly;
    private Message message;

    @Builder
    @AllArgsConstructor
    @Getter
    public static class Message {
        private Notification notification;
        private String token;
    }

    @Builder
    @AllArgsConstructor
    @Getter
    public static class Notification {
        private String title;
        private String body;
        private String image;
    }
}
```

## Postman 테스트 (특정 기기 전송)

[앱 서버 전송 요청 작성  |  Firebase 클라우드 메시징](https://firebase.google.com/docs/cloud-messaging/send-message?hl=ko#rest)

- 위 사이트를 보면

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2035.png)

- Http요청 예시는 다음과 같다.
- 요청을 보내기 위해서는, `서버 키`와 `타겟 기기의 토큰`을 알아야 한다.

### 서버 키

- FCMService의  getAccessToken()을 log로 출력하면 다음과 같이 알 수 있다.

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2036.png)

- ya29는 구글 내부 인증 방식의 토큰이다. jwt처럼 해독해서 볼 수는 없다.

### 타겟 기기 토큰

- MainActivity에 다음과 같이 선언하면, Logcat 콘솔에서 토큰을 알 수 있다.

```java
FirebaseMessaging.getInstance().getToken()
    .addOnCompleteListener(new OnCompleteListener<String>() {
        @Override
        public void onComplete(@NonNull Task<String> task) {
            if (task.isSuccessful()) {
                // 토큰 값 추출
                String token = task.getResult();
                System.out.println("Token : " + token);

            } else {
                System.out.println("wrong");
            }
        }
    });
```

### Postman

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2037.png)

### post 링크

```java
https://fcm.googleapis.com/v1/projects/{project-id}/messages:send
```

- 인데, project-id는 firebase console에서 알 수 있다.

### 헤더

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2038.png)

```java
"Content-type" : "application/json",
"Authorization" : "Bearer + {웹 서버 토큰}
```

### Body-json

```json
{
    "message" : {
        "token" : "기기토큰",
        "notification" : {
            "title" : "Alarmony" ,
            "body" : "초대가 도착했습니다"
    }
    } 

}
```

### 결과

![Untitled](%E1%84%91%E1%85%A9%E1%84%90%E1%85%B5%E1%86%BC%E1%84%86%E1%85%A6%E1%84%82%E1%85%B2%E1%84%8B%E1%85%A5%E1%86%AF%203345f6ddb76b449394d17cf63c6c3be8/Untitled%2039.png)